create type "public"."community_role" as enum ('admin', 'member');

create table "public"."communities" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "secret" boolean not null default false
);


alter table "public"."communities" enable row level security;

create table "public"."communities_requests" (
    "id" bigint generated by default as identity not null,
    "user" uuid not null,
    "community" bigint not null,
    "accepted" boolean,
    "updated_at" timestamp without time zone not null default now()
);


alter table "public"."communities_requests" enable row level security;

create table "public"."communities_users" (
    "id" bigint generated by default as identity not null,
    "community" bigint not null,
    "user" uuid not null,
    "role" community_role not null default 'member'::community_role
);


alter table "public"."communities_users" enable row level security;

alter table "public"."armies" add column "secret" boolean not null default true;

alter table "public"."games" add column "community" bigint;

CREATE UNIQUE INDEX communities_pkey ON public.communities USING btree (id);

CREATE UNIQUE INDEX communities_users_pkey ON public.communities_users USING btree (id);

CREATE UNIQUE INDEX community_requests_pkey ON public.communities_requests USING btree (id);

alter table "public"."communities" add constraint "communities_pkey" PRIMARY KEY using index "communities_pkey";

alter table "public"."communities_requests" add constraint "community_requests_pkey" PRIMARY KEY using index "community_requests_pkey";

alter table "public"."communities_users" add constraint "communities_users_pkey" PRIMARY KEY using index "communities_users_pkey";

alter table "public"."communities_requests" add constraint "community_requests_community_fkey" FOREIGN KEY (community) REFERENCES communities(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."communities_requests" validate constraint "community_requests_community_fkey";

alter table "public"."communities_requests" add constraint "community_requests_user_fkey" FOREIGN KEY ("user") REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."communities_requests" validate constraint "community_requests_user_fkey";

alter table "public"."communities_users" add constraint "communities_users_community_fkey" FOREIGN KEY (community) REFERENCES communities(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."communities_users" validate constraint "communities_users_community_fkey";

alter table "public"."communities_users" add constraint "communities_users_user_fkey" FOREIGN KEY ("user") REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."communities_users" validate constraint "communities_users_user_fkey";

alter table "public"."games" add constraint "games_community_fkey" FOREIGN KEY (community) REFERENCES communities(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."games" validate constraint "games_community_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_user(name text, password text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
  declare
  user_id uuid;
  encrypted_pw text;
  email text;
BEGIN
  -- Concatenate the name with the domain to form the email
  email := name || '@appdeptus.com';
  
  user_id := gen_random_uuid();
  encrypted_pw := crypt(password, gen_salt('bf'));
  
  -- Insert user with the display_name set to the provided name
  INSERT INTO auth.users
    (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, recovery_sent_at, last_sign_in_at, raw_app_meta_data, raw_user_meta_data, created_at, updated_at, confirmation_token, email_change, email_change_token_new, recovery_token)
  VALUES
    ('00000000-0000-0000-0000-000000000000', user_id, 'authenticated', 'authenticated', email, encrypted_pw, '2023-05-03 19:41:43.585805+00', '2023-04-22 13:10:03.275387+00', '2023-04-22 13:10:31.458239+00', '{"provider":"email","providers":["email"]}', jsonb_build_object('display_name', name), '2023-05-03 19:41:43.580424+00', '2023-05-03 19:41:43.585948+00', '', '', '', '');
  
  -- Insert identity with the provider_id and other details
  INSERT INTO auth.identities (id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at, provider_id)
  VALUES
    (gen_random_uuid(), user_id, format('{"sub":"%s","email":"%s"}', user_id::text, email)::jsonb, 'email', '2023-05-03 19:41:43.582456+00', '2023-05-03 19:41:43.582497+00', '2023-05-03 19:41:43.582497+00', gen_random_uuid());
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_community()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$BEGIN
  INSERT INTO communities_users (community, "user", role)
  VALUES (NEW.id, auth.uid(), 'admin');
  RETURN NEW;
END;$function$
;

grant delete on table "public"."communities" to "anon";

grant insert on table "public"."communities" to "anon";

grant references on table "public"."communities" to "anon";

grant select on table "public"."communities" to "anon";

grant trigger on table "public"."communities" to "anon";

grant truncate on table "public"."communities" to "anon";

grant update on table "public"."communities" to "anon";

grant delete on table "public"."communities" to "authenticated";

grant insert on table "public"."communities" to "authenticated";

grant references on table "public"."communities" to "authenticated";

grant select on table "public"."communities" to "authenticated";

grant trigger on table "public"."communities" to "authenticated";

grant truncate on table "public"."communities" to "authenticated";

grant update on table "public"."communities" to "authenticated";

grant delete on table "public"."communities" to "service_role";

grant insert on table "public"."communities" to "service_role";

grant references on table "public"."communities" to "service_role";

grant select on table "public"."communities" to "service_role";

grant trigger on table "public"."communities" to "service_role";

grant truncate on table "public"."communities" to "service_role";

grant update on table "public"."communities" to "service_role";

grant delete on table "public"."communities_requests" to "anon";

grant insert on table "public"."communities_requests" to "anon";

grant references on table "public"."communities_requests" to "anon";

grant select on table "public"."communities_requests" to "anon";

grant trigger on table "public"."communities_requests" to "anon";

grant truncate on table "public"."communities_requests" to "anon";

grant update on table "public"."communities_requests" to "anon";

grant delete on table "public"."communities_requests" to "authenticated";

grant insert on table "public"."communities_requests" to "authenticated";

grant references on table "public"."communities_requests" to "authenticated";

grant select on table "public"."communities_requests" to "authenticated";

grant trigger on table "public"."communities_requests" to "authenticated";

grant truncate on table "public"."communities_requests" to "authenticated";

grant update on table "public"."communities_requests" to "authenticated";

grant delete on table "public"."communities_requests" to "service_role";

grant insert on table "public"."communities_requests" to "service_role";

grant references on table "public"."communities_requests" to "service_role";

grant select on table "public"."communities_requests" to "service_role";

grant trigger on table "public"."communities_requests" to "service_role";

grant truncate on table "public"."communities_requests" to "service_role";

grant update on table "public"."communities_requests" to "service_role";

grant delete on table "public"."communities_users" to "anon";

grant insert on table "public"."communities_users" to "anon";

grant references on table "public"."communities_users" to "anon";

grant select on table "public"."communities_users" to "anon";

grant trigger on table "public"."communities_users" to "anon";

grant truncate on table "public"."communities_users" to "anon";

grant update on table "public"."communities_users" to "anon";

grant delete on table "public"."communities_users" to "authenticated";

grant insert on table "public"."communities_users" to "authenticated";

grant references on table "public"."communities_users" to "authenticated";

grant select on table "public"."communities_users" to "authenticated";

grant trigger on table "public"."communities_users" to "authenticated";

grant truncate on table "public"."communities_users" to "authenticated";

grant update on table "public"."communities_users" to "authenticated";

grant delete on table "public"."communities_users" to "service_role";

grant insert on table "public"."communities_users" to "service_role";

grant references on table "public"."communities_users" to "service_role";

grant select on table "public"."communities_users" to "service_role";

grant trigger on table "public"."communities_users" to "service_role";

grant truncate on table "public"."communities_users" to "service_role";

grant update on table "public"."communities_users" to "service_role";

create policy "all"
on "public"."communities"
as permissive
for all
to public
using (true)
with check (true);


create policy "all"
on "public"."communities_requests"
as permissive
for all
to public
using (true)
with check (true);


create policy "all"
on "public"."communities_users"
as permissive
for all
to public
using (true)
with check (true);


CREATE TRIGGER after_community_insert AFTER INSERT ON public.communities FOR EACH ROW EXECUTE FUNCTION handle_new_community();


